use crate::*;
use radix_engine_common::crypto::PublicKey;
use radix_engine_common::data::scrypto::model::NonFungibleLocalId;
use radix_engine_common::data::scrypto::model::Own;
use radix_engine_common::data::scrypto::{scrypto_decode, scrypto_encode, ScryptoValue};
use radix_engine_common::math::Decimal;
use radix_engine_common::time::Instant;
use radix_engine_common::types::GlobalAddress;
use radix_engine_interface::blueprints::resource::NonFungibleGlobalId;
use sbor::rust::fmt::Debug;
use sbor::rust::prelude::*;
use sbor::Value;

pub const METADATA_BLUEPRINT: &str = "Metadata";

#[derive(Debug, Clone, Eq, PartialEq, ScryptoSbor, ManifestSbor)]
pub enum MetadataValue {
    String(String),
    Bool(bool),
    U8(u8),
    U32(u32),
    U64(u64),
    I32(i32),
    I64(i64),
    Decimal(Decimal),
    Address(GlobalAddress),
    PublicKey(PublicKey),
    NonFungibleGlobalId(NonFungibleGlobalId),
    NonFungibleLocalId(NonFungibleLocalId),
    Instant(Instant),
    Url(Url),
}

pub const METADATA_VALUE_STRING_TYPE_ID: u8 = 0u8;
pub const METADATA_VALUE_BOOLEAN_TYPE_ID: u8 = 1u8;
pub const METADATA_VALUE_U8_TYPE_ID: u8 = 2u8;
pub const METADATA_VALUE_U32_TYPE_ID: u8 = 3u8;
pub const METADATA_VALUE_U64_TYPE_ID: u8 = 4u8;
pub const METADATA_VALUE_I32_TYPE_ID: u8 = 5u8;
pub const METADATA_VALUE_I64_TYPE_ID: u8 = 6u8;
pub const METADATA_VALUE_DECIMAL_TYPE_ID: u8 = 7u8;
pub const METADATA_VALUE_ADDRESS_TYPE_ID: u8 = 8u8;
pub const METADATA_VALUE_PUBLIC_KEY_TYPE_ID: u8 = 9u8;
pub const METADATA_VALUE_NON_FUNGIBLE_GLOBAL_ID_TYPE_ID: u8 = 10u8;
pub const METADATA_VALUE_NON_FUNGIBLE_LOCAL_ID_TYPE_ID: u8 = 11u8;
pub const METADATA_VALUE_INSTANT_TYPE_ID: u8 = 12u8;
pub const METADATA_VALUE_URL_TYPE_ID: u8 = 13u8;

#[derive(Debug, Clone, Eq, PartialEq, ScryptoSbor, ManifestSbor)]
#[sbor(transparent)]
pub struct Url(pub String);

#[derive(Debug, Clone, Eq, PartialEq, ScryptoSbor, ManifestSbor)]
pub enum MetadataEntry {
    Value(MetadataValue),
    List(Vec<MetadataValue>),
}

pub const METADATA_ENTRY_VALUE_TYPE_ID: u8 = 0u8;
pub const METADATA_ENTRY_LIST_TYPE_ID: u8 = 1u8;

pub trait MetadataVal: Sized {
    const TYPE_ID: u8;

    fn to_scrypto_value(self) -> ScryptoValue;

    fn from_scrypto_value(value: ScryptoValue) -> Self;

    fn to_metadata_entry(self) -> ScryptoValue {
        ScryptoValue::Enum {
            discriminator: METADATA_ENTRY_VALUE_TYPE_ID,
            fields: vec![ScryptoValue::Enum {
                discriminator: Self::TYPE_ID,
                fields: vec![self.to_scrypto_value()],
            }],
        }
    }

    fn from_metadata_entry(entry: ScryptoValue) -> Result<Self, MetadataError> {
        match entry {
            ScryptoValue::Enum {
                discriminator,
                fields,
            } if discriminator == METADATA_ENTRY_VALUE_TYPE_ID => {
                let value = fields.into_iter().next().unwrap();
                let (discriminator, value) = match value {
                    ScryptoValue::Enum {
                        discriminator,
                        fields,
                    } => {
                        let value = fields.into_iter().next().unwrap();
                        (discriminator, value)
                    }
                    _ => panic!("Unexpected"),
                };
                if discriminator == Self::TYPE_ID {
                    Ok(Self::from_scrypto_value(value))
                } else {
                    Err(MetadataError::NotAString)
                }
            }
            _ => panic!("Unexpected"),
        }
    }
}

macro_rules! metadata_sbor_type {
    ($t:ty, $type_id:ident, $scrypto_value_type:ident) => {
        impl MetadataVal for $t {
            const TYPE_ID: u8 = $type_id;

            fn to_scrypto_value(self) -> ScryptoValue {
                Value::$scrypto_value_type { value: self }
            }

            fn from_scrypto_value(value: ScryptoValue) -> Self {
                match value {
                    Value::$scrypto_value_type { value } => value,
                    _ => panic!("Unexpected"),
                }
            }
        }
    };
}

macro_rules! metadata_scrypto_type {
    ($t:ty, $type_id:ident) => {
        impl MetadataVal for $t {
            const TYPE_ID: u8 = $type_id;

            fn to_scrypto_value(self) -> ScryptoValue {
                let scrypto_value: ScryptoValue =
                    scrypto_decode(&scrypto_encode(&self).unwrap()).unwrap();
                scrypto_value
            }

            fn from_scrypto_value(value: ScryptoValue) -> Self {
                let key: $t = scrypto_decode(&scrypto_encode(&value).unwrap()).unwrap();
                key
            }
        }
    };
}

metadata_sbor_type!(String, METADATA_VALUE_STRING_TYPE_ID, String);
metadata_sbor_type!(bool, METADATA_VALUE_BOOLEAN_TYPE_ID, Bool);
metadata_sbor_type!(u8, METADATA_VALUE_U8_TYPE_ID, U8);
metadata_sbor_type!(u32, METADATA_VALUE_U32_TYPE_ID, U32);
metadata_sbor_type!(u64, METADATA_VALUE_U64_TYPE_ID, U64);
metadata_sbor_type!(i32, METADATA_VALUE_I32_TYPE_ID, I32);
metadata_sbor_type!(i64, METADATA_VALUE_I64_TYPE_ID, I64);
metadata_scrypto_type!(Decimal, METADATA_VALUE_DECIMAL_TYPE_ID);
metadata_scrypto_type!(GlobalAddress, METADATA_VALUE_ADDRESS_TYPE_ID);
metadata_scrypto_type!(PublicKey, METADATA_VALUE_PUBLIC_KEY_TYPE_ID);
metadata_scrypto_type!(NonFungibleGlobalId, METADATA_VALUE_PUBLIC_KEY_TYPE_ID);
metadata_scrypto_type!(
    NonFungibleLocalId,
    METADATA_VALUE_NON_FUNGIBLE_LOCAL_ID_TYPE_ID
);
metadata_scrypto_type!(Instant, METADATA_VALUE_INSTANT_TYPE_ID);
metadata_scrypto_type!(Url, METADATA_VALUE_URL_TYPE_ID);

#[derive(Debug, Clone, Eq, PartialEq, ScryptoSbor)]
pub enum MetadataError {
    NotAString,
    EmptyEntry,
}

pub const METADATA_CREATE_IDENT: &str = "create";

#[derive(
    Debug, Clone, Eq, PartialEq, ScryptoSbor, ManifestCategorize, ManifestEncode, ManifestDecode,
)]
pub struct MetadataCreateInput {}

pub type MetadataCreateOutput = Own;

pub const METADATA_CREATE_WITH_DATA_IDENT: &str = "create_with_data";

#[derive(
    Debug, Clone, Eq, PartialEq, ScryptoSbor, ManifestCategorize, ManifestEncode, ManifestDecode,
)]
pub struct MetadataCreateWithDataInput {
    pub data: BTreeMap<String, String>,
}

pub type MetadataCreateWithDataOutput = Own;

pub const METADATA_SET_IDENT: &str = "set";

#[derive(Debug, Clone, Eq, PartialEq, ScryptoSbor)]
pub struct MetadataSetInput {
    pub key: String,
    pub value: ScryptoValue,
}

pub type MetadataSetOutput = ();

pub const METADATA_GET_IDENT: &str = "get";

#[derive(
    Debug, Clone, Eq, PartialEq, ScryptoSbor, ManifestCategorize, ManifestEncode, ManifestDecode,
)]
pub struct MetadataGetInput {
    pub key: String,
}

pub type MetadataGetOutput = Option<ScryptoValue>;

pub const METADATA_REMOVE_IDENT: &str = "remove";

#[derive(
    Debug, Clone, Eq, PartialEq, ScryptoSbor, ManifestCategorize, ManifestEncode, ManifestDecode,
)]
pub struct MetadataRemoveInput {
    pub key: String,
}

pub type MetadataRemoveOutput = bool;
